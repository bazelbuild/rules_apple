#!/usr/bin/env bash
set -eu

# The path where the archive should be created, including the name of the
# archive itself.
readonly OUTPUT_PATH=%output_path%
# The name of the ipa post processor executable, if any, that should be run on
# the directory containing the package contents.
readonly POST_PROCESSOR=%ipa_post_processor%
# Indicates whether the final archive should be compressed (1) or not (0).
readonly SHOULD_COMPRESS=%should_compress%
# The path to archive with the unprocessed and unsigned bundle.
readonly UNPROCESSED_ARCHIVE_PATH=%unprocessed_archive_path%
# The absolute path to the directory where the unprocessed archive will be
# extracted for post-processing and signing.
readonly WORK_DIR=%work_dir%

# Blow away the old working dir if it's still there from a previous build.
if [[ -d "$WORK_DIR" ]]; then
  chmod -R u+w "$WORK_DIR"
  rm -rf "$WORK_DIR"
fi
mkdir -p "$WORK_DIR"

# Expand the unprocessed archive into the temporary directory.
unzip -qq -d "$WORK_DIR" "$UNPROCESSED_ARCHIVE_PATH"

# Execute the archive post-processor, if it was provided.
if [[ -n "$POST_PROCESSOR" ]]; then
  "$POST_PROCESSOR" "$WORK_DIR"
fi

# Strip out any unnecessary slices from embedded dynamic frameworks to save space
for i in "$WORK_DIR"/*.app; do
    # Lets figure out what slices the app has
    app_name=$(basename $i .app)
    slices=$(xcrun lipo -info $i/$app_name | cut -d: -f3)

    # Now lets make sure any included frameworks match
    for f in $i/Frameworks/*.framework; do
        # We need to check we have overlapping architectures
        framework_name=$(basename $f .framework)
        framework_slices=$(xcrun lipo -info $f/$framework_name | cut -d: -f3)
        # Sanity check that the framework has at least the slices the app has
        for s in $slices ; do
            echo $framework_slices | grep -q $s
            if [ $? -ne 0 ]; then
                echo "App has slice $s, but $f does not. Aborting..."
                exit -1
            fi
        done

        # Now make the framework match the slices the app has
        for s in $slices ; do
            lipo_args="$lipo_args -extract $s"
        done
        xcrun lipo $f/$framework_name $lipo_args -output $temp_file
        if [ $? -ne 0 ]; then
            echo lipo failed, aborting...
            exit 1
        fi
        file $temp_file
        mv $temp_file $f/$framework_name
    done
done

# Sign the application, if requested. This may expand to nothing in the case
# where signing is not being performed.
%signing_command_lines%

if [[ "$SHOULD_COMPRESS" == "1" ]]; then
  readonly COMPRESSION_METHOD=deflate
else
  readonly COMPRESSION_METHOD=store
fi

# Create the final ZIP archive and copy it into its destination in bazel-bin/.
readonly OUTPUT_BASENAME=$(basename "$OUTPUT_PATH")
pushd "$WORK_DIR" >/dev/null
# Ensure that the entries in the ZIP are writable when expanded, because some
# tools rely on the ability to unzip it, modify it, and re-sign it.
chmod -R u+w .
( TZ=UTC find . -exec touch -h -t 198001010000 {} \+ )
zip -qX -r --compression-method "$COMPRESSION_METHOD" "$OUTPUT_BASENAME" .
popd >/dev/null
mv "$WORK_DIR/$OUTPUT_BASENAME" "$OUTPUT_PATH"
