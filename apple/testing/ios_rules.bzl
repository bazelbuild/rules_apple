# Copyright 2017 The Bazel Authors. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Bazel rules for iOS tests."""

load("@build_bazel_rules_apple//apple:providers.bzl",
     "AppleBundleInfo",
     "IosXcTestBundleInfo")
load("@build_bazel_rules_apple//apple:utils.bzl",
     "full_label",
     "merge_dictionaries")
load("@build_bazel_rules_apple//apple/bundling:apple_bundling_aspect.bzl",
     "apple_bundling_aspect")
load("@build_bazel_rules_apple//apple/bundling:bundler.bzl",
     "bundler")
load("@build_bazel_rules_apple//apple/bundling:product_support.bzl",
     "apple_product_type")
load("@build_bazel_rules_apple//apple/bundling:rule_attributes.bzl",
     "common_rule_attributes")
load("@build_bazel_rules_apple//apple/testing:apple_test_rules.bzl",
     "apple_unit_test",
     "apple_ui_test")


def _ios_test_bundle_attributes():
  """Returns the attributes for the _ios_test_bundle rule."""
  return merge_dictionaries(
      common_rule_attributes(),
      {
          # Override of the common_rule_attributes() binary attribute in
          # order to make it only accept loadable_bundle apple_binary targets.
          "binary": attr.label(
              aspects=[apple_bundling_aspect],
              mandatory=True,
              providers=[apple_common.AppleLoadableBundleBinary],
              single_file=True,
          ),
          # Override of the common_rule_attributes() bundle_id attribute in
          # order to make it optional. Bundle identifier for the
          # _ios_test_bundle output.
          "bundle_id": attr.string(),
          # Internal name for the bundle. Used so that the output .xctest bundle
          # has the same name as the test target and avoid Tulsi the confusion
          # of the internal paths.
          "bundle_name": attr.string(mandatory=True),
          # The product type (either a UI test or unit test bundle) set by the
          # wrapping macro.
          "product_type": attr.string(mandatory=True),
          # The test host that will run these tests. This is required in order to
          # obtain a sensible default for the tests bundle identifier.
          "test_host": attr.label(mandatory=True, providers=[AppleBundleInfo]),
          "_allowed_families": attr.string_list(default=["iphone", "ipad"]),
          # The extension of the bundle being generated by the rule.
          "_bundle_extension": attr.string(default=".xctest"),
          # Name of the attribute that contains the internal bundle name.
          "_bundle_name_attr": attr.string(default="bundle_name"),
          # .xctest bundles should include a PkgInfo file.
          "_needs_pkginfo": attr.bool(default=True),
          # A format string used to compose the path to the bundle inside the
          # packaged archive. The placeholder "%s" is replaced with the name of the
          # bundle (with its extension).
          "_path_in_archive_format": attr.string(default="Payload/%s"),
          # The platform type that should be passed to tools for targets of this
          # type.
          "_platform_type": attr.string(default=str(apple_common.platform_type.ios)),
          # Don't require signing for test bundles when building for devices.
          "_requires_signing_for_device": attr.bool(default=False),
      }
  )


def _ios_test_bundle_impl(ctx):
  """Implementation for the _ios_test_bundle rule."""
  host_bundle_info = ctx.attr.test_host[AppleBundleInfo]
  bundle_id = host_bundle_info.bundle_id + "Tests"
  if ctx.attr.bundle_id:
    bundle_id = ctx.attr.bundle_id

  if not bundle_id:
    fail("Bundle identifier missing. You need to either provide a test_host " +
         "or a bundle_id.")

  if bundle_id == host_bundle_info.bundle_id:
    fail("The test bundle's identifier of '" + bundle_id + "' can't be the " +
         "same as the test host's bundle identifier. Please change one of " +
         "them.")

  additional_providers, legacy_providers, additional_outputs = bundler.run(
      ctx,
      "IosTestArchive", "IosTest",
      bundle_id)
  return struct(
      files=depset([ctx.outputs.archive]) + additional_outputs,
      instrumented_files=struct(dependency_attributes=["binary", "test_host"]),
      providers=[
          IosXcTestBundleInfo(),
      ] + additional_providers,
      **legacy_providers
  )

_ios_test_bundle = rule(
    _ios_test_bundle_impl,
    attrs=_ios_test_bundle_attributes(),
    outputs = {
        # TODO(b/34774324): Rename to zip.
        "archive": "%{name}.ipa",
    },
    fragments = ["apple", "objc"],
)


def _ios_test(name,
              product_type,
              bundle_id=None,
              bundle_loader=None,
              infoplists=[
                  "@build_bazel_rules_apple//apple/testing:DefaultTestBundlePlist",
              ],
              minimum_os_version=None,
              runner=None,
              test_rule=None,
              test_host=None,
              deps=[],
              **kwargs):
  """Macro that routes the external macro arguments into the correct targets.

  This macro creates 3 targets:

  * name + "_test_binary": Represents the binary that contains the test code. It
      captures the deps and test_host arguments.
  * name + "_test_bundle": Represents the xctest bundle that contains the binary
      along with the test resources. It captures the bundle_id and infoplists
      arguments.
  * name: The actual test target that can be invoked with `blaze test`. This
      target takes all the remaining arguments passed.
  """
  test_binary_name = name + "_test_binary"
  test_bundle_name = name + "_test_bundle"

  native.apple_binary(
      name = test_binary_name,
      deps = deps,
      sdk_frameworks = ["XCTest"],
      binary_type = "loadable_bundle",
      bundle_loader = bundle_loader,
      minimum_os_version = minimum_os_version,
      visibility = ["//visibility:private"],
      testonly = 1,
  )

  _ios_test_bundle(
      name = test_bundle_name,
      binary = ":" + test_binary_name,
      bundle_name = name,
      bundle_id = bundle_id,
      infoplists = infoplists,
      minimum_os_version = minimum_os_version,
      product_type = product_type,
      test_host = test_host,
      testonly = 1,
      visibility = ["//visibility:private"],
  )

  test_rule(
      name = name,
      test_host = test_host,
      test_bundle = test_bundle_name,
      runner = runner,
      **kwargs)


def ios_unit_test(
    name,
    runner = "@build_bazel_rules_apple//apple/testing/default_runner:ios_default_runner",
    test_host = "@build_bazel_rules_apple//apple/testing/default_host/ios",
    **kwargs):
  bundle_loader = full_label(test_host) + ".apple_binary"
  _ios_test(
      name = name,
      product_type = apple_product_type.unit_test_bundle,
      bundle_loader = bundle_loader,
      runner = runner,
      test_rule = apple_unit_test,
      test_host = test_host,
      **kwargs
  )


def ios_ui_test(
    name,
    runner = "@build_bazel_rules_apple//apple/testing/default_runner:ios_default_runner",
    **kwargs):
  _ios_test(
      name = name,
      product_type = apple_product_type.ui_test_bundle,
      runner = runner,
      test_rule = apple_ui_test,
      **kwargs
  )
