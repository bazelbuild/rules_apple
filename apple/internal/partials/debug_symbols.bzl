# Copyright 2018 The Bazel Authors. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Partial implementation for debug symbol file processing."""

load(
    "@bazel_skylib//lib:partial.bzl",
    "partial",
)
load(
    "@bazel_skylib//lib:paths.bzl",
    "paths",
)
load(
    "@bazel_skylib//lib:shell.bzl",
    "shell",
)
load(
    "@build_bazel_apple_support//lib:apple_support.bzl",
    "apple_support",
)
load(
    "@build_bazel_rules_apple//apple:providers.bzl",
    "AppleDsymBundleInfo",
)
load(
    "@build_bazel_rules_apple//apple/internal:outputs.bzl",
    "outputs",
)
load(
    "@build_bazel_rules_apple//apple/internal:providers.bzl",
    "new_appledsymbundleinfo",
)
load(
    "@build_bazel_rules_apple//apple/internal/providers:apple_debug_info.bzl",
    "AppleDebugInfo",
)
load(
    "@build_bazel_rules_apple//apple/internal/utils:defines.bzl",
    "defines",
)

visibility("@build_bazel_rules_apple//apple/...")

def _declare_linkmap(
        *,
        actions,
        arch,
        debug_output_filename,
        linkmap):
    """Declares a linkmap for this binary.

    Args:
        actions: The actions provider from `ctx.actions`.
        arch: The architecture specified for this particular debug output.
        debug_output_filename: The base file name to use for this debug output, which will be
            followed by the architecture with an underscore to make this linkmap's file name.
        linkmap: The linkmap that was generated by the linking action.

    Returns:
        A linkmap file for the given architecture.
    """
    output_linkmap = actions.declare_file(
        "%s_%s.linkmap" % (debug_output_filename, arch),
    )
    actions.symlink(target_file = linkmap, output = output_linkmap)
    return output_linkmap

def _collect_linkmaps(
        *,
        actions,
        debug_output_filename,
        linkmaps = {}):
    """Collects the available linkmaps from the binary.

    Args:
        actions: The actions provider from `ctx.actions`.
        debug_output_filename: The base file name to use for this debug output, which will be
            followed by each architecture with an underscore to make each linkmap's file name.
        linkmaps: A mapping of architectures to Files representing linkmaps for each architecture.

    Returns:
        A list of linkmap files, one per linked architecture.
    """
    outputs = []

    if linkmaps:
        for arch, linkmap in linkmaps.items():
            outputs.append(_declare_linkmap(
                actions = actions,
                arch = arch,
                debug_output_filename = debug_output_filename,
                linkmap = linkmap,
            ))

    return outputs

def _lipo_command_for_dsyms(
        *,
        found_dsyms_by_arch,
        main_binary_basename):
    """Returns a shell command to invoke lipo against all provided dSYMs for a given bundle.

    Args:
        found_dsyms_by_arch: A mapping of architectures to Files representing dsym outputs for each
            architecture.
        main_binary_basename: The basename of the main unstripped binary that was linked to generate
            the dSYM.

    Returns:
        A String representing the shell command to invoke lipo, referencing an OUTPUT_DIR shell
        variable that is expected to represent the dSYM bundle root.
    """
    found_binary_paths = []
    for dsym_bundle in found_dsyms_by_arch.values():
        found_binary = dsym_bundle.path + paths.join(
            "/Contents/Resources/DWARF",
            main_binary_basename,
        )
        found_binary_paths.append(found_binary)

    lipo_command = (
        'mkdir -p "${{OUTPUT_DIR}}/Contents/Resources/DWARF" && ' +
        "/usr/bin/lipo " +
        "-create {found_binary_inputs} " +
        '-output "${{OUTPUT_DIR}}/Contents/Resources/DWARF/{main_binary_basename}"'
    ).format(
        found_binary_inputs = " ".join([shell.quote(path) for path in found_binary_paths]),
        main_binary_basename = main_binary_basename,
    )

    return lipo_command

def _ditto_command_for_dsyms(*, found_binaries_by_arch):
    """Returns a shell command to invoke ditto against the provided dSYMs for a given bundle.

    Args:
        found_binaries_by_arch: A mapping of architectures to Files representing dsym outputs for
            each architecture.

    Returns:
        A String representing the shell command to invoke ditto, referencing an OUTPUT_DIR shell
        variable that is expected to represent the dSYM bundle root.
    """
    found_binary_paths = []
    for dsym_binary in found_binaries_by_arch.values():
        found_binary_paths.append(dsym_binary.path + "/Contents/Resources/Relocations")

    ditto_command = (
        'mkdir -p "${{OUTPUT_DIR}}/Contents/Resources/Relocations" && ' +
        "/usr/bin/ditto " +
        "{found_binary_inputs} " +
        '"${{OUTPUT_DIR}}/Contents/Resources/Relocations"'
    ).format(
        found_binary_inputs = " ".join([shell.quote(path) for path in found_binary_paths]),
    )

    return ditto_command

def _generate_merged_dsym_bundle(
        *,
        actions,
        bundle_extension = "",
        bundle_name,
        debug_output_filename,
        dsym_inputs = {},
        output_discriminator,
        platform_prerequisites):
    """Returns a merged .dSYM bundle assembled from the provided dSYMs, if any.

    The generated bundle will have the same name as the bundle being built (including its
    extension), but with the ".dSYM" extension appended to it.

    If the target being built does not have a binary or if the build it not generating debug
    symbols (`--apple_generate_dsym` is not provided), then this function is a no-op that returns
    an empty list.

    Args:
        actions: The actions provider from `ctx.actions`.
        bundle_extension: The extension for the bundle.
        bundle_name: The name of the output bundle.
        debug_output_filename: The base file name to use for this debug output, which will be
            followed by each architecture with an underscore to make each dSYM binary file name or
            with the bundle extension following it for the dSYM bundle file name.
        dsym_inputs: A mapping of architectures to Files representing dSYM outputs for each
            architecture.
        output_discriminator: A string to differentiate between different target intermediate files
            or `None`.
        platform_prerequisites: Struct containing information on the platform being targeted.

    Returns:
        A File representing the tree artifact representation of the .dSYM bundle with the dSYM
        binaries lipoed together as one binary, if any dsym_inputs were provided. If only one dSYM
        bundle in the dictionary of dsym_inputs was provided, the tree artifact returned will be an
        unmodified reference to that dSYM bundle. If no dsym_inputs were provided, `None` is
        returned.
    """

    if not dsym_inputs:
        return None

    # The name of the main binary is currently contingent on the Objective-C fragment's
    # `builtin_objc_strip_action` attribute, which determines *how* the unstripped binary is
    # named as an artifact.
    main_binary_basename = outputs.main_binary_basename(
        cpp_fragment = platform_prerequisites.cpp_fragment,
        bundle_name = bundle_name,
        # LINT.IfChange
        unstripped = platform_prerequisites.objc_fragment.builtin_objc_strip_action,
        # LINT.ThenChange(../compilation_support.bzl)
    )

    command_inputs = dsym_inputs.values()

    if len(dsym_inputs) == 1 and not output_discriminator:
        # If we only have one dSYM bundle and we don't need to rename the dSYM bundle, we can
        # just use it as-is, no need to merge + lipo its contents.
        return dsym_inputs.values()[0]

    # 1. Lipo the binaries (Resources/DWARF/{main_binary_basename}).
    lipo_command = _lipo_command_for_dsyms(
        found_dsyms_by_arch = dsym_inputs,
        main_binary_basename = main_binary_basename,
    )

    # 2. Merge the files within (Resources/Relocations, Info.plist).
    ditto_command = _ditto_command_for_dsyms(found_binaries_by_arch = dsym_inputs)

    # We expect any given Info.plist from the splits to be as good as any, no need to merge
    # them, but we can do that with plisttool if and when it's needed.
    plist_command = (
        'cp {dsym_plist_path} "${{OUTPUT_DIR}}/Contents/Info.plist"'
    ).format(
        dsym_plist_path = shell.quote(dsym_inputs.values()[0].path + "/Contents/Info.plist"),
    )

    command = (
        'rm -rf "${OUTPUT_DIR}" && ' +
        lipo_command + " && " +
        ditto_command + " && " +
        plist_command
    )

    dsym_bundle_dir = actions.declare_directory(
        "{debug_output_filename}{bundle_extension}.dSYM".format(
            debug_output_filename = debug_output_filename,
            bundle_extension = bundle_extension,
        ),
    )

    apple_support.run_shell(
        actions = actions,
        apple_fragment = platform_prerequisites.apple_fragment,
        inputs = command_inputs,
        outputs = [dsym_bundle_dir],
        command = command,
        env = {
            "OUTPUT_DIR": dsym_bundle_dir.path,
        },
        mnemonic = "DSYMBundleCopy",
        xcode_config = platform_prerequisites.xcode_version_config,
    )

    return dsym_bundle_dir

def _debug_symbols_partial_impl(
        *,
        actions,
        bundle_extension,
        bundle_name,
        debug_dependencies = [],
        debug_discriminator = None,
        dsym_outputs = {},
        linkmaps = {},
        output_discriminator = None,
        platform_prerequisites):
    """Implementation for the debug symbols processing partial."""
    deps_dsym_bundle_providers = [
        x[AppleDsymBundleInfo]
        for x in debug_dependencies
        if AppleDsymBundleInfo in x
    ]
    deps_debug_info_providers = [
        x[AppleDebugInfo]
        for x in debug_dependencies
        if AppleDebugInfo in x
    ]

    debug_output_filename = bundle_name
    if debug_discriminator:
        debug_output_filename += "_" + debug_discriminator

    direct_dsym_bundles = []
    transitive_dsym_bundles = [x.transitive_dsyms for x in deps_dsym_bundle_providers]

    direct_linkmaps = []
    transitive_linkmaps = [x.linkmaps for x in deps_debug_info_providers]

    output_providers = []

    if platform_prerequisites.cpp_fragment:
        if platform_prerequisites.cpp_fragment.apple_generate_dsym:
            dsym_bundle_dir = _generate_merged_dsym_bundle(
                actions = actions,
                bundle_extension = bundle_extension,
                bundle_name = bundle_name,
                debug_output_filename = debug_output_filename,
                dsym_inputs = dsym_outputs,
                output_discriminator = output_discriminator,
                platform_prerequisites = platform_prerequisites,
            )
            if dsym_bundle_dir:
                direct_dsym_bundles.append(dsym_bundle_dir)

        if platform_prerequisites.cpp_fragment.objc_generate_linkmap:
            linkmaps = _collect_linkmaps(
                actions = actions,
                debug_output_filename = debug_output_filename,
                linkmaps = linkmaps,
            )
            direct_linkmaps.extend(linkmaps)

    # Only output dependency debug files if requested.
    propagate_embedded_extra_outputs = defines.bool_value(
        config_vars = platform_prerequisites.config_vars,
        define_name = "apple.propagate_embedded_extra_outputs",
        default = False,
    )

    linkmaps_group = depset(direct_linkmaps, transitive = transitive_linkmaps)

    all_output_dsyms = depset(direct_dsym_bundles, transitive = transitive_dsym_bundles)
    direct_output_dsyms = direct_dsym_bundles

    if propagate_embedded_extra_outputs:
        output_files = depset(transitive = [all_output_dsyms, linkmaps_group])
    else:
        output_files = depset(direct_output_dsyms + direct_linkmaps)

    output_providers.extend([
        new_appledsymbundleinfo(
            direct_dsyms = direct_dsym_bundles,
            transitive_dsyms = depset(direct_dsym_bundles, transitive = transitive_dsym_bundles),
        ),
        AppleDebugInfo(
            linkmaps = linkmaps_group,
        ),
    ])

    return struct(
        output_files = output_files,
        output_groups = {
            "dsyms": all_output_dsyms,
            "linkmaps": linkmaps_group,
        },
        providers = output_providers,
    )

def debug_symbols_partial(
        *,
        actions,
        bundle_extension,
        bundle_name,
        debug_dependencies = [],
        debug_discriminator = None,
        dsym_outputs = {},
        linkmaps = {},
        output_discriminator = None,
        platform_prerequisites):
    """Constructor for the debug symbols processing partial.

    This partial collects all of the transitive debug files information. The output of this partial
    are the debug output files for the target being processed _plus_ all of the dependencies debug
    symbol files. This includes dSYM bundles and linkmaps. With this, for example, by building an
    ios_application target with --apple_generate_dsym, this partial will return the dSYM bundle of
    the ios_application itself plus the dSYM bundles of any ios_framework and ios_extension
    dependencies there may be, which will force bazel to present these files in the output files
    section of a successful build.

    Args:
        actions: The actions provider from `ctx.actions`.
        bundle_extension: The extension for the bundle.
        bundle_name: The name of the output bundle.
        debug_dependencies: List of targets from which to collect the transitive dependency debug
            information to propagate them upstream.
        debug_discriminator: A suffix to distinguish between different debug output files, or
            `None`.
        dsym_outputs: A mapping of architectures to Files representing dsym outputs for each
            architecture.
        linkmaps: A mapping of architectures to Files representing linkmaps for each architecture.
        output_discriminator: A string to differentiate between different target intermediate files
            or `None`.
        platform_prerequisites: Struct containing information on the platform being targeted.

    Returns:
        A partial that returns the debug output files, if any were requested.
    """
    return partial.make(
        _debug_symbols_partial_impl,
        actions = actions,
        bundle_extension = bundle_extension,
        bundle_name = bundle_name,
        debug_dependencies = debug_dependencies,
        debug_discriminator = debug_discriminator,
        dsym_outputs = dsym_outputs,
        linkmaps = linkmaps,
        output_discriminator = output_discriminator,
        platform_prerequisites = platform_prerequisites,
    )
