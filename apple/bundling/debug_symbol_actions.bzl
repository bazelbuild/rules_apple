# Copyright 2017 The Bazel Authors. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Actions to manipulate debug symbol outputs."""

load("@build_bazel_rules_apple//apple/bundling:file_actions.bzl", "file_actions")

def _collect_linkmaps(ctx, debug_outputs, bundle_name):
    """Collects the available linkmaps from the binary.

    Args:
      ctx: The current context.
      debug_outputs: dSYM bundle binary provider.
      bundle_name: Anticipated name of the dSYM bundle.

    Returns:
      A list of linkmap files, one per linked architecture.
    """
    outputs = []
    actions = ctx.actions

    # TODO(b/36174487): Iterate over .items() once the Map/dict problem is fixed.
    for arch in debug_outputs.outputs_map:
        arch_outputs = debug_outputs.outputs_map[arch]
        linkmap = arch_outputs["linkmap"]
        out_linkmap = actions.declare_file("%s_%s.linkmap" % (bundle_name, arch))
        outputs.append(out_linkmap)
        file_actions.symlink(ctx, linkmap, out_linkmap)

    return outputs

def _create_symbol_bundle(ctx, debug_outputs, bundle_name, bundle_extension = ""):
    """Creates the .dSYM bundle next to the output archive.

    The generated bundle will have the same name as the bundle being built
    (including its extension), but with the ".dSYM" extension appended to it.

    If the target being built does not have a binary or if the build it not
    generating debug symbols (`--apple_generate_dsym` is not provided), then this
    function is a no-op that returns an empty list.

    This function assumes that the target has a user-provided binary in the
    `binary` attribute. It is the responsibility of the caller to check this.

    Args:
      ctx: The Skylark context.
      debug_outputs: dSYM bundle binary provider.
      bundle_name: Anticipated name of the dSYM bundle.
      bundle_extension: Anticipated extension of the dSYM bundle, empty string if
                        it does not have one.

    Returns:
      A list of files that comprise the .dSYM bundle, which should be returned as
      additional outputs from the rule.
    """
    dsym_bundle_name = bundle_name + bundle_extension + ".dSYM"

    outputs = []
    actions = ctx.actions

    # TODO(b/36174487): Iterate over .items() once the Map/dict problem is fixed.
    for arch in debug_outputs.outputs_map:
        arch_outputs = debug_outputs.outputs_map[arch]
        dsym_binary = arch_outputs["dsym_binary"]
        out_symbols = actions.declare_file("%s/Contents/Resources/DWARF/%s_%s" % (
            dsym_bundle_name,
            bundle_name,
            arch,
        ))
        outputs.append(out_symbols)
        file_actions.symlink(ctx, dsym_binary, out_symbols)

    # If we found any outputs, create the Info.plist for the bundle as well;
    # otherwise, we just return the empty list. The plist generated by dsymutil
    # only varies based on the bundle name, so we regenerate it here rather than
    # propagate the other one from the apple_binary. (See
    # https://github.com/llvm-mirror/llvm/blob/master/tools/dsymutil/dsymutil.cpp)
    if outputs:
        out_plist = actions.declare_file("%s/Contents/Info.plist" %
                                         dsym_bundle_name)
        outputs.append(out_plist)
        actions.expand_template(
            template = ctx.file._dsym_info_plist_template,
            output = out_plist,
            substitutions = {
                "%bundle_name_with_extension%": bundle_name + bundle_extension,
            },
        )

    return outputs

# Define the loadable module that lists the exported symbols in this file.
debug_symbol_actions = struct(
    collect_linkmaps = _collect_linkmaps,
    create_symbol_bundle = _create_symbol_bundle,
)
